\section[Distributed Systems]{Distributed Systems}\label{sec:newsec}
Distributed architecture is a design approach where the logical components of an application are divided into multiple units.
These units each run in their individual process and communicate with each other over the network.
This architecture style encourages loose coupling of each service, which could be a huge benefit.

There are multiple advantages to choosing distributed systems. The one that contrasts with the monolithic architecture is
scalability. Since distributed architectures deploy different logical components separately from one another, it is easy to add new services.
Furthermore, similar to modular monolithics, distributed architecture encourages a high degree of modularity.
This is because distributed systems have loosely coupled logical components.
The benefit of having multiple distributed systems is also shown during the testing phase as well. Since each unit is
loosely coupled, they can be tested separately. This becomes a huge advantage as the size of the application grows compared to
monolithic systems. Lastly, fault tolerance is a big difference compared to the monolithic system as multiple units are
deployed in several units. Even though one part of the system is down, the other parts of the system could still be available
depending on the coupling.

On the other hand, there are also disadvantages when choosing to build a distributed systems architecture.
Performance is generally slower than a monolithic application since distributed system architectures involve
lots of small services that communicate with each other over the network.
This can affect performance, but there are ways to improve this.
Another aspect is cost, since more servers are needed to deploy multiple units.
These services will need to talk to each other, which entails setting up and maintaining network infrastructure.
This leads to more complexity in the system, and makes it more challenging for the developers harder to understand the overall design.
Also, errors could happen in any unit involved in servicing a request. Since logical components are deployed in separate units,
tracing errors could become complicated.


% Pros:
% -	Scalability: Distributed architectures deploy different logical components separately from one another, so it is easy to add new services.
% -	Modularity: Distributed architecture encourage a high degree of modularity because their logical components must be loosely coupled.
% -	Testablility: Each deployment only serves a select group of logical components. This makes testing a log easier-even as the application grows.
% -	Deployability: Distributed architectures encourage lots of small units. They evolved after modern engineering principles like continuous integration, 
%   continuous deployments, and automated testing became the norm.
% -	Fault Tolerance: Even if one piece of the system fails, the rest of the system can continue functioning.
% Cons:
% -	Performance: Distributed architectures involve lots of small services that communicate with each other over the network.
%   This can affect performance, but there are ways to improve this.
% -	Cost: More servers are needed to deploy multiple units. These services will need to talk to each other, which entails setting up and maintaining network infrastructure.
% -	Simplicity: Distributed systems are complicated to understand from how they work to debugging errors.
% -	Debuggability: Errors could happen in any unit involved in servicing a request. Since logical components are deployed in separate units,
%   tracing errors could become complicated.

There are both advantages and disadvantages of monolithic and distributed systems, and choosing the appropriate architecture for each situation is crucial.
After deciding which of the two main architecture will be used, then we could decide on which subcategory of either of the architectures to implement.
Each types of subcategories, have their own advantages and disadvantages.

\subsection[Microservices Architecture]{Microservices Architecture}

A microservice is a service that is a separately deployed unit of software that performs some business or infrastructure process \cite{Gandhi_Richards_Ford_2024}.
% (chapter 10).
Microservices architecture is part of the layered system, where microservices communicate with each other to make an application.
Since the system is divided into multiple parts, it is essential when making decisions how to divide the application,
such as deciding how small or how big each microservices could get. Generally, it is better to make microservices smaller for
multiple reasons. Some of the factors that are considered to make microservices
smaller are the following: cohesiveness, fault tolerance, access control, code volatility, and scalability.

If a part of the software has lack of cohesiveness and loosely coupled, it is a good idea to separate it into smaller microservices. 
Here, cohesiveness means that how close the parts of the application are related to each other \cite{Gandhi_Richards_Ford_2024}.
This will allow higher scalability, since separated microservices could be built independently based on the workload and resource requirements.
If a certain part of the application produces fatal errors,
having those parts in a separate microservice will decrease the probability of shutting down the whole system.
For security and authentication, it is important to have these access controls in a single microservice,
so it does not get too complicated when managing the information. Finally, if one part of the microservice change,
or scale faster than the others, it is good to consider having a separate microservice for that application,
since testing the entire microservice would be much more challenging compared to a small portion of the microservice.

On the other hand, there are times when it is encouraged to make the microservices bigger: Database transactions, data dependencies, and workflow.
It is not possible to perform a single database commit or rollback when a request involves multiple microservices.
For data consistency and integrity, it is important to combine functionalities that require this kind of behavior into a single microservice.
If a part of a microservice has highly coupled data, such as when a database table refers to the key of another database table,
it is better to keep these functionalities as a single microservice to keep the data integrity of the database.
Furthermore, if a single request requires separate microservices to communicate with each other, 
this request is coupled and recommended to kept in the same service. \\

% \textbf{Needs Revision. Needs Clear explanation of negative effects of tight coupling.}
% Understanding the negative effects of tight coupling in microservices is also crucial.
% For example, performance is affected by the network, security, and data latency.
% Scalability is affected because each microservice in the call chain must scale as the other microservices scale.
% For instance, let's assume that there is a call chain from A to B to C. If the microservice A needed to accept 5 times more trafic,
% it is necessary to adjust all three services needs to scale. 
% Fault tolerance is affected because if one of the microservices in the chain becomes unresponsive or unavailable, the request cannot be processed.
% It is good practice to consider the workflow and decide whether to keep the microservice big or separate it into smaller microservices.\\


\noindent \textbf{Workflows}

After setting up multiple microservices, the next question is how these microservices communicate with each other
to make the whole application. This is a crucial part of the microservices architecture,
and this is where workflow comes in.
The term workflow means when two or more microservices are called for a single request.
Workflows are in charge of navigating which microservice to start, which one to call next, and which one to end with.
There are two ways to handle workflows: centralized workflow management and decentralized workflow management.

% \noindent \textbf{Centralized workflow management}

The first type of workflow management style is the centralized workflow. This workflow management style is where there is a microservice that coordinates all the microservices that are needed to handle a
certain single request. This microservice will be responsible for calling all related microservices, knowing the current state of the
workflow and what happens next, summarize all data from each microservice, and handle errors.

The advantage of this workflow management style is that the order of microservices for each request is clear.
The central microservice always has the exact routes the request has to take, which allows to track the status of where all requests stopped and where to restart.
This allows more efficient error handling and simplifies the process of changing a workflow.

The disadvantage is the tight coupling between the central microservice and the other microservices.
This can lead to lower scalability, since changing a microservice will affect the central microservice.
Moreover, performance might get delayed since the central microservice is indeed another microservice that requires remote calls, 
and it saves the workflow state data in a database, which slows down the performance. 

% \noindent \textbf{Decentralized workflow management}	

The next type of workflow management style is the decentralized workflow. This workflow does not have a central microservice,
but rather all microservices redirect to another microservice
by the given request until the request is complete. It is important not to use one of the microservices as a central microservice.

The advantage of using this workflow pattern is that it is loosely coupled compared to the central workflow management,
which has better scalability. Also, since the microservices do not have to connect back to the central microservice,
it has better responsiveness, meaning less delay and better performance.

On the other hand, this pattern lacks in error handling, since each microservice is responsible for managing the error workflow,
which could lead to too much communication between services. Also, because there is no central microservice that has the order
of microservices that is need to be called, it is hard to tell which state the response is at, which decreases the ability to recover
when the request is delayed and needs to be restarted.


\noindent \textbf{Sharing functionalities}

There are many times when the same code has to be used in multiple microservices.
There are mainly two ways for sharing code when building a microservice architecture.
Creating a shared service or a shared library.
A shared service is a separate microservice that contains a shared functionality that other microservices can call remotely.
One advantage of the shared service is that even though code may change in the shared microservices, code in other microservices are not needed to be changed.
Also, this shared service could be written in any language, which is useful when microservices are implemented in multiple languages.
A disadvantage of using a shared service is the coupling that happens between the microservices and the shared service.
This leads to risks when changing a shared service since it can affect the other microservices that call it.
Furthermore, when the shared service is down for some reason, the microservices that require the shared service would not function.

% Another disadvantage is network latency, â€¦.

A shared library is a more common way for code reuse. A library will be built, including all the code that is reused in different microservices.
Once the microservices are deployed, each microservice will have all the shared functionality available.
The biggest advantage of using a shared library is that network performance and scalability are better than shared service,
since it is not remote, and the code is included in the compile time of the microservice.
However, multiple shared libraries will be needed if microservices are written in different programming languages.
Also, managing dependencies between microservices and shared libraries could be a challenge if there are multiple microservices using the shared code.\\


\noindent \textbf{Pros and Cons of Microservice Architecture.}

Microservice architectures are commonly used as they have several advantages.
Loose coupling is one of them. Each microservice is single-purpose, and they are deployed separately,
which makes them easy to maintain. This means that it is easy to change a particular microservice that needs modification,
instead of making multiple changes in different parts of the whole application.
Also, it is easy to test the application, as the scope is much smaller compared to the monolithic architecture.
Fault tolerance is another advantage that comes from loose coupling. Even if a particular microservice fails,
it does not break the whole system. Furthermore, microservice architecture is easy to scale and evolve since we just have to add or
modify a microservice related to the area.

However, there are also disadvantages when using the microservice architecture. 
This architecture is complex. It requires multiple decisions, such as the aspects discussed above (workflow, shared code etc.)
depending on the situation. Because of its complexity, as microservices communicate with each other, the performance also decreases.
The request might have to wait for the network or undergo additional security checks and make extra database calls.
Lastly, deploying all of these microservices will increase the cost of the entire application.  

\subsection[Event-Driven Architecture (EDA)]{Event-Driven Architecture (EDA)}
\noindent \textbf{What is an Event}

An event in computer science is a way for a service to let the rest of the system know that something important has just happened.
In EDA, events are the means of passing information to other services \cite{Gandhi_Richards_Ford_2024} .
% (head first chapter11).
The event contains data, and it is broadcast to services using topics that are connected to the sender of the event.
However, events are asynchronous, which means that although the services are connected,
the sender of the event does not wait for the response of the receiving service.
This is the key difference between an event and a message. Messages include a command or some kind of request for the receiving service,
and the service sending out the messages requires a response, making it synchronous.
Messages are also sent to only a single service using queues. \\

\noindent \textbf{Asynchronous Communication}

EDA relies on asynchronous communication when sending and receiving events. This is because events in the EDA do not wait for a response
and is built for loose coupling.
Asynchronous communications do not need to wait for a response, even though the receiving services are available or not.
These kinds of communications are also called Fire and Forget. On the other hand, synchronous communication needs to stop and wait for the response,
which means that the service in response must be available. This make tighter coupling between services, making it not suitable for EDA. \\

\noindent \textbf{Pros and Cons of EDA}

Asynchronous communications have advantages in responsiveness compared to synchronous communications.
Since responses by the receiving services are unnecessary, it takes less time to complete a request.
However, this is also a crucial disadvantage. Since we do not know if the receiving services have successfully completed the request,
it is prone to error handling. 
% Here is a diagram.

Event-Driven Architecture is highly decoupled, which makes all services independent and easy to maintain.
Furthermore, asynchronous communication increases the performance of the application.
Since EDAs are highly decoupled with this type of communication, it is easy to scale and evolve.

On the other hand, there are also disadvantages that need to be considered.
Similar to microservices, EDAs are complex. Deciding which database topology for the architecture,
asynchronous communications and parallel event processing add complexity to the application.
Also, asynchronous communication makes it more difficult to test out the program.
Since the request is processed without any response or synchronous calls, the context of the test is vague.
If the application needs multiple synchronous calls, EDA is not the right choice for the product.

