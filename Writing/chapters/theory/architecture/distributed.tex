\subsection[Distributed Systems]{Distributed Systems}\label{sec:newsec}
Distributed architecture is when the logical componnents of the application are split up into multiple units. 
These units each run in their individual process and communicate with each other over the network. 
This architecture style encourage loose coupling of each services. The general pros and cons of this architecture style are the following:

Pros:
-	Scalability: Distributed architectures deploy different logical components separately from one another, so it is easy to add new services.
-	Modularity: Distributed architecture encourage a high degree of modularity because their logical components must be loosely coupled.
-	Testablility: Each deployment only serves a select group of logical components. This makes testing a log easier-even as the application grows.
-	Deployability: Distributed architectures encourage lots of small units. They evolved after modern engineering principles like continuous integration, 
  continuous deployments, and automated testing became the norm.
-	Fault Tolerance: Even if one piece of the system fails, the rest of the system can continue functioning.
Cons:
-	Performance: Distributed architectures involve lots of small services that communicate with each other over the network.
  This can affect performance, but there are ways to improve this.
-	Cost: More servers are needed to deploy multiple units. These services will need to talk to each other, which entails setting up and maintaining network infrastructure.
-	Simplicity: Distributed systems are complicated to understand from how they work to debugging errors.
-	Debuggability: Errors could happen in any unit involved in servicing a request. Since logical components are deployed in separate units,
  tracing errors could become complicated.

There are both advantages and disadvantages for monolithic and distributed systems and choosing the appropriate architecture for each situation is crucial.
After deciding which of the two main architecture will be used, then we could decide on which subcategory of either of the architecture to implement.
Same as the monolithic structure, distributed systems architecture has multiple types of subcategories, each having advantages and disadvantages. 

\subsubsection[Microservices Architecture]{Microservices Architecture}

A microservice is a service that is separately deployed unit of software that performs some business or infrastructure process.(chapter 10).
A microservices architecture is part of the layered system, where microservices communicate which each other to make an application. 
Since the system is divided into multiple parts, it is essential how to divide the application, 
such as deciding how small or how big each microservices could get into. Generally, it is better to make microservices smaller for 
multiple reasons. Some of the factors that is considered to make microservices 
smaller are the following: cohesiveness, fault tolerance, access control, code volatility, and scalability. 

If a part of the software has lack of cohesiveness and loosely coupled, it is a good idea to separate it into smaller microservices. 
This will allow higher scalability. If a certain part of the application produces fatal errors, 
having those part in a sparate microservice will decrease the probability to shut down the whole system. 
For security and authentication, it is important to have these access controlabilities into a single microservice, 
so it does not get too complicated when managing the information. Finally, if one part of the microservice change, 
or scale faster than the others, it is good to consider to have a separate microservice for that application, 
since testing the entire microservice would be much more challenging compared to a small portion of the microservice. 

On the other hand, there are times when it is encouraged to make the microservices bigger: Database transactions, data dependencies, and workflow. 
It is not possible to perform a single database commit or rollback when a request involves multiple microservices. 
For data consistency and integrity, it is important to combine functionalities that require these kind of behavior into a single microservice. 
If a part of a microservice has highly coupled data, such as when a database table refers to  the key of another database table, 
it is better to keep these functionalities as a single microservice, to keep the data integrity of the database. 
If a single request requires separate microservices to communicate with each other, this request is coupled. 
If too much coupling is occurred between microsesrvices, there are many negative effects. 
For example, performance is affected by network, security, and data latency. 
Scalability is affected because each microservice in the call chain must scale as the other microservices scale (something that is hard to coordinate).
Fault tolerance is affected because if one of the microservices in the chain becomes unresponsive or unavailable, the request cannot be processed.
It is good practice to consider the workflow and decide whether to keep the microservice big.\\

\noindent \textbf{Balance}

\noindent Sharing functionalities

There are many times when the same code has to be used in multiple microservices. 
There are mainly two ways for sharing code when building a microservice architecture. 
Creating a shared service, or a shared library.  
A shared service is a separate microservice that contains a shared functionality that other microservices can call remotely.
The advantages of using this is that eventhough a code is changed in the shared microservices, code in other microservices are not required to change.
Also, this shared service could be written in any language, which is useful when microservices are implemented in multiple languages. 
A disadvantage of using a shared service is coupling that happens between the microservices and the shared service. 
This leads to risks when changing a shared service since it can affect the other microservices that call it.
Furthermore, when the shared service is down for some reason, the microservices that require the shared service would not function.
Another disadvantage is network latency, â€¦.

A shared library is a more common way for code reuse. A library will be built including all the code that are reused in different microsesrvices,
and once they microservices are deployed, each microservice will have all the shared functionality available. 
The biggest advantage of using a shared library is that network performance and scalability is better than shared service, 
since it is not remote and the code is included in the compile time of the microservice. 
However, multiple shared libraries will be needed if microservices are written in different programming languages. 
Also, managing dependencies between microservices and shared libraries could be a challenge if there are multiple microservices using the shared code. \\


\noindent \textbf{Workflow}

Microservices communicate with each other to make the whole application. It is important to know how these are connected, 
and this is where workflow comes in.
The term workflow means when two or more microservices are called for a single request. 
Workflows are in charge of navigating which microservice to start, which one to call next, and which one to end with.
There are two ways to handle workflows: centralized workflow management, and decentralized workflow management. 

\noindent \textbf{Centralized workflow management}

This workflow management style is where there is a microservice that coordinates all the microservices that are needed to handle a 
certain single request. This microservice will be responsible for calling all related microservices, knowing the current state of the 
workflow and what happens next, summarize all data from each microservice, and handling errors. 

The advantage of this workflow management style is that the order of microservices for each requests are clear. The central microservice always has the exact routes the request hast to take, which allows to track the status where each requests stopped and where to restart. This allows to handle errors efficiently. Also, it is easy to change a workflow since this all changes in one central microservice.

The disadvantage is that tight coupling between the central microservice and the other microservices. This can lead to lower scalability, since changing a microservice will affect the central microservice. Moreover, performance might get delayed since the central microservice is indeed another microservice that requires remote calls and it saves the workflow state data in a database which slows down the performance. 

\noindent \textbf{Decentralized workflow management}	

The decentralized workflow does not have a central microservice, but rather all microservices redirect to another microservice 
by the given request until the request is complete. It is important to not use one of the microservices as a central microservice.

The advantage of using this workflow pattern is that it is loosely coupled compared to the central workflow management, 
which has better scalability. Also, since the microservices does not have to connect back to the central microservice, 
it has better responsiveness, meaning less delay and better performance. 

On the other hand, this pattern lacks in error handling, since each microservice is responsible for managing the error workflow, 
which could lead to too much communication between services. Also, because there is not a central microservice that has the order 
of microservices that needs to be called, it is hard to tell which state the response is at, which decreases the ability to recover 
when the request is delayed and needs to be restarted again. 

\noindent \textbf{Pros and Cons of microservice architecture.}

Microservice architectures are commonly used and it is important when choosing this software architecture. 
There are multiple advantages when choosing to implement the microservice architecture. 
Loose coupling is a huge advantage. Since each microservices are single-purpose and they are deployed separately, 
and easy to maintain. This means that it is easy to change a particular function that needs modification. 
Also, it is easy to test the application, as the scope is much smaller compared to the monolithic architecture. 
Fault tolerance is another advantage that comes from loose coupling. Even if a particular microservice fails, 
it does not break the whole system. Furthermore, microservice architecture is easy to scale and evolve since we just have to add or 
modify a microservice related to the area. 

However, there are also disadvantages of using the microservice architecture. 
This architecture is complex. It requires multiple decisions(the aspects discussed above: workflow, shared code etc..) 
depending on the situation. Since it is complex, as microservices communicate with each other, the performance also decreases.
The request might have to wait for the network or undergo additional security checks and make extra database calls.
Lastly, deploying all of these microservices will increase the cost of the entire application.  

\subsubsection[Event-Driven Architecture(EDA)]{Event-Driven Architecture(EDA)}
\noindent \textbf{What is an Event}

An event in computer science is a way for a service to let the rest of the system know that something important has just happened. In EDA, events are the means of passing information to other services (head first chapter11). The event contains data and it is broadcasted to services using topics that are connected to the sender of the event. However, events are asynchronous, which means that although the services are connected, the sender of the event does not wait on the response of the receiving service. This is the key difference between a event and message. Messages includes a command or some kind of a request for the receiving service, and the service sending out the messages require a response, making it synchronous. Messages are also sent to only a single service using queues. 

\noindent \textbf{Asynchronous vs Synchronous}

Asynchronous communications do not need to wait for the response, even though the receiving services are available or not. These kinds of communications are also called Fire and Forget. On the other hand, synchronous communication needs to stop and wait until the response, which means that the service in response must be available. EDA relies on the asynchronous communication when sending and receiving events.

\noindent \textbf{Advantages, Disadvantages of Asynchronous Communications}

Asynchronous communications has advantages in responsiveness compared to synchronous communications. Since responses by the receiving services are unnecessary, it takes less time to complete a request. However, this is also a crucial disadvantage. Since we do not know if the receiving services have successfully completed the request, it is prone to error handling. Here is a diagram. 

\noindent \textbf{Advantages of EDA}

Event Driven Architecture is highly decoupled, which makes all services independent and easy to maintain. Furthermore, the asynchronous communication increases the performance of the application. Since EDAs are highly decoupled with this type of communication, it is easy to scale and evolve. 
Disadvantages of EDA
Similar to microservices, EDAs are complex. Deciding which database topology for the architecture, asynchronous communications and parallel event processing makes adds complexity to the application. Also, asynchronous communication makes it more difficult to test out the program. Since the request is proceeded without any response or synchronous calls, the context of the test is vague. If the application needs multiple synchronous calls, EDA is not the right choice for the product. 

