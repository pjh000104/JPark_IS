\section[Caching Invalidation]{Caching Invalidation}
After a cache is stored whether in the client or the server side, it is crucial to know when the cache should be validated.
For example, let's assume the user's profile is cached in the browser. Without any caching invalidation, even after the user's
profile is updated, the user will not be able to see the changes if the cache still exists in the browser. 
This could lead to crucial data inconsistency as the importance of the data increases such as sensitive security data.
Caching invalidation strategies are needed to set when the cache should be stored, updated, or deleted.
Choosing the right caching invalidation strategy can lead to better performance of the application, freeing up the memory space
and increasing cache-hit rates. 

% I will be explaining about dependency ID first, since it is a term that will be mentioned often in the following paragraphs.
% A dependency ID is a label used to identify which cache should be invalidated, and the same label can be attached to multiple cache entries.
% By doing this, group is created that can be removed all together when certain conditions are met. The conditions will be the different types 
% of caching validation which will be explained in the pargarphs bellow. This group allows the developers to structure cache making
% caching invalidation easier and more organized. 

One of the most common types of cache invalidation is time-based invalidation. This type of technique invalidates cached data
after a certain time period has passed, which could be decided by the developers \cite{Redis_2025}.
Although it is simple and widely used, it also has limitations because it may invalidate data too early or too late depending on the situation.
In some systems, a timeout value can be added directly in a cache configuration file to specify how long the entry should stay valid.
This value can also be customized to fit the needs of the application. 
Some examples of time-based invalidation could be a recipe website may refresh its cache daily to show the latest trending dishes, 
or a movie streaming service that could be refreshed where there are new releases every few hours.

Another type of invalidation is event-based invalidation, which happens when a specific event is triggered in the system.
This is useful when the cached data is tied closely to an event or state change.
For example, when a blog post is updated, the old cached version of the post should be removed so that users can see the most recent version right away.
This ensures that the content stays consistent with changes happening inside the system.

Another type is group-based invalidation, which removes cache based on a larger group or category.
This is helpful when many cache entries belong to the same section of the application, and clearing them one by one would be inefficient \cite{Redis_2025}.
This type of cache invalidation technique is commonly used when a larger group of data must be invalidated at once.
For example, on a news website, if the politics section is updated, all cached articles under that section should be
invalidated to make sure the latest content is displayed. In eCommerce systems, updating a product category may require invalidating all caches related to that category.

Lastly, there is validation-based invalidation. This cache invalidation technique relies on the browser checking with the server to see if
the cached data is still valid instead of removing it after a fixed time or when an event occurs \cite{Redis_2025}.
A common technique for this is using ETags, which are small identifiers generated by the server to represent a specific version of a resource.
When the browser stores a cached file, it also keeps the ETag value and later sends it back to the server to confirm whether the resource has changed.
If it has not changed, the server replies with a “Not Modified” response, which allows the browser to continue using the cached version without downloading it again.
This approach helps reduce unnecessary network usage while still ensuring that users receive the most up-to-date content,
making it useful for situations where data changes unpredictably.

Not all of these caching strategies could be used both in the server side and the client side. 
Each technique serves a different purpose, and some are only effective when controlled by the system that manages the data.
Time-based invalidation is mostly handled on the server side through cache headers,
while event-based and group-based invalidation occur exclusively on the server since they depend on changes happening within the application itself \cite{Redis_2025}.
On the other hand, validation-based methods such as ETags rely on collaboration between the browser and the server,
where the server generates validation tokens and the client uses them to check freshness.
Understanding where each technique is applied helps ensure that caching remains efficient, consistent, and aligned with the needs of the application.

% Another common technique is no-cache, which still allows the browser to cache the resource,
% but requires it to check with the server before using the cached version.
% This is useful for files that change more frequently, such as HTML documents or some API responses.
% Even though the browser revalidates the file, it does not have to download the whole resource again unless it has changed.
% This helps balance performance while still keeping the content up to date.

% The no-store is a caching invalidation technique when there is no need for the browser to store data in any type of cache.
% Because of this the no-store technique is commonly used for sensitive or private data.  
% This is important for pages that include personal information, financial data, or authentication flows.
% By preventing the browser from saving these resources, the application can reduce the risk of exposing sensitive data on the client side.

% Short-lived caching is another practical approach where resources are cached for a short amount of time.
% The key difference between this technique and the time-based cache invalidation technique is the amount of time the cache is stored.
% Short-lived caching stores cache a few seconds or minutes, while time-based caching is generally more longer. 
% This strategy works well for information that does not need to be real-time but still updates often,
% like live sports games, news feeds, or dashboard statistics. Using short-lived caching can reduce the number of requests sent to the server,
% while still keeping the user experience smooth. 


% https://redis.io/glossary/cache-invalidation/